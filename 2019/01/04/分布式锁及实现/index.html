<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="分布式锁及实现"><meta name="keywords" content="redis,分布式锁"><meta name="author" content="Guo,undefined"><meta name="copyright" content="Guo"><title>分布式锁及实现 | 『人生一世，草木一秋』</title><link rel="shortcut icon" href="/img/icon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基于数据库实现"><span class="toc-number">1.</span> <span class="toc-text">基于数据库实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基于redis实现"><span class="toc-number">2.</span> <span class="toc-text">基于redis实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基于ZK实现"><span class="toc-number">3.</span> <span class="toc-text">基于ZK实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Guo</div><div class="author-info__description text-center">当你知道早晨为何醒来的时候，你也就找到了活着的意义和价值。</div><div class="follow-button"><a href="tencent://message/?uin=81387949&amp;amp;Menu=yes" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">23</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="人生一世" target="_blank">人生一世</a><a class="author-info-links__name text-center" href="草木一秋" target="_blank">草木一秋</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/background.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">『人生一世，草木一秋』</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a><a class="site-page" href="/java.html">Java大纲</a></span></div><div id="post-info"><div id="post-title">分布式锁及实现</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-04</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
</blockquote>
<p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。</p>
<ul>
<li>基于数据库实现分布式锁；</li>
<li>基于缓存（Redis等）实现分布式锁；</li>
<li>基于Zookeeper实现分布式锁；</li>
</ul>
<p>在分析这几种实现方案之前我们先来想一下，我们需要的分布式锁应该是怎么样的？（这里以方法锁为例，资源锁同理）</p>
<blockquote>
<p>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。<br>这把锁要是一把可重入锁（避免死锁）<br>这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）<br>有高可用的获取锁和释放锁功能<br>获取锁和释放锁的性能要好</p>
</blockquote>
<a id="more"></a>
<h1 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h1><blockquote>
<p>基于数据库表实现（唯一性索引）</p>
</blockquote>
<p>最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。</p>
<p>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。</p>
<p>（1）创建这样一张数据库表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `method_lock` (</span><br><span class="line">  `id` <span class="keyword">int</span>(<span class="number">11</span>) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'主键'</span>,</span><br><span class="line">  `method_name` varchar(<span class="number">64</span>) NOT NULL COMMENT <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  `desc` varchar(<span class="number">255</span>) NOT NULL COMMENT <span class="string">'备注信息'</span>,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`id`)</span>,</span></span><br><span class="line"><span class="function">  UNIQUE KEY `uidx_method_name` <span class="params">(`method_name`)</span> USING BTREE</span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="number">3</span> DEFAULT CHARSET=utf8 COMMENT=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<p>（2）当我们想要锁住某个方法时，执行以下SQL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INSERT INTO <span class="title">method_lock</span> <span class="params">(method_name, desc)</span> <span class="title">VALUES</span> <span class="params">(<span class="string">'methodName'</span>, <span class="string">'测试的methodName'</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>（3）成功插入则获取锁，执行完成后删除对应的行数据释放锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from method_lock where method_name =<span class="string">'methodName'</span>;</span><br></pre></td></tr></table></figure>
<p>上面这种简单的实现有以下几个问题：</p>
<ol>
<li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<p>当然，我们也可以有其他方式解决上面的问题。</p>
<ul>
<li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li>
<li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li>
<li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li>
<li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ul>
<h1 id="基于redis实现"><a href="#基于redis实现" class="headerlink" title="基于redis实现"></a>基于redis实现</h1><p>（1）Redis有很高的性能；<br>（2）Redis命令对此支持较好，实现起来比较方便</p>
<p>命令介绍：</p>
<p>（1）SETNX<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回<span class="number">1</span>；若key存在，则什么都不做，返回<span class="number">0</span>。</span><br></pre></td></tr></table></figure></p>
<p>（2）expire<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</span><br></pre></td></tr></table></figure></p>
<p>（3）delete<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete key：删除key</span><br></pre></td></tr></table></figure></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis Lock：redis锁（注意：必须在事务外使用，否则解锁-事务提交之间，可能被其他线程lock，导致脏读）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisLock.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String[] keys;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> expireSeconds; <span class="comment">// 过期时间</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> retrySeconds; <span class="comment">// 重试时间</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> timeValue = <span class="number">0</span>; <span class="comment">// lock设置的时间戳：0 失败；&gt;0 时间戳</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String lockPrefix;<span class="comment">// 前缀</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; lockKeys; <span class="comment">// 已加锁的key列表</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(String[] keys, <span class="keyword">int</span> expireSeconds, <span class="keyword">int</span> retrySeconds)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.keys= keys;</span><br><span class="line">		<span class="keyword">this</span>.expireSeconds = expireSeconds;</span><br><span class="line">		<span class="keyword">this</span>.retrySeconds = retrySeconds;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getExpireSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> expireSeconds;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExpireSeconds</span><span class="params">(<span class="keyword">int</span> expireSeconds)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.expireSeconds = expireSeconds;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRetrySeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> retrySeconds;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRetrySeconds</span><span class="params">(<span class="keyword">int</span> retrySeconds)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.retrySeconds = retrySeconds;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String[] getKeys() &#123;</span><br><span class="line">		<span class="keyword">return</span> keys;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getKeyString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StringUtils.join(<span class="keyword">this</span>.keys, <span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> timeValue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getLockKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lockKeys;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排序自旋锁：setnx &amp;&amp; expire</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//双重检查单例Redis</span></span><br><span class="line">		Jedis jedis = Redis.getInstance().getJedis();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Arrays.sort(keys);</span><br><span class="line">			lockKeys.clear();</span><br><span class="line">			<span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">			<span class="comment">// 避免死锁：value = 当前时间 + 过期时间 + 1毫秒</span></span><br><span class="line">			<span class="keyword">this</span>.timeValue = now + expireSeconds * <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">					String lockKey = lockPrefix + key;</span><br><span class="line">					<span class="keyword">if</span> (lockKeys.contains(lockKey))</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">					Long ret = jedis.setnx(lockKey, String.valueOf(timeValue));</span><br><span class="line">					<span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">						<span class="comment">// 使用expire，如果代码运行至此，redis连接崩溃，该key没有设置超时时间 =&gt; 死锁</span></span><br><span class="line">						jedis.expire(lockKey, expireSeconds);</span><br><span class="line">						lockKeys.add(lockKey);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 解决死锁：判断key对应的value是否超时</span></span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						String currentValueStr = jedis.get(lockKey);</span><br><span class="line">						<span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() &gt; Long.valueOf(currentValueStr)) &#123;</span><br><span class="line">							<span class="comment">// 并发竞争：getset取出旧值再判断一次，避免被其他线程set</span></span><br><span class="line">							String oldValueStr = jedis.getSet(lockKey, String.valueOf(timeValue));</span><br><span class="line">							<span class="keyword">if</span> (oldValueStr == <span class="keyword">null</span> || oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">								lockKeys.add(lockKey);</span><br><span class="line">								<span class="keyword">continue</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 全部锁住</span></span><br><span class="line">				<span class="keyword">if</span> (lockKeys.size() == keys.length) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 超时未成功：释放加的锁</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (System.currentTimeMillis() - now &gt; retrySeconds * <span class="number">1000</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (lockKeys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						jedis.del(lockKeys.toArray(<span class="keyword">new</span> String[lockKeys.size()]));</span><br><span class="line">						lockKeys.clear();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				Thread.sleep(<span class="number">200</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			logger.warn(<span class="string">"获取redis lock异常"</span>, e);</span><br><span class="line">			<span class="keyword">if</span> (lockKeys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				jedis.del(lockKeys.toArray(<span class="keyword">new</span> String[lockKeys.size()]));</span><br><span class="line">				lockKeys.clear();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			Redis.getInstance().close(jedis);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解锁：删除 key（从redis线程池未获取到jedis =&gt; 解锁失败）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//双重检查单例Redis</span></span><br><span class="line">		Jedis jedis = Redis.getInstance().getJedis();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (String lockKey : lockKeys) &#123;</span><br><span class="line">				String valueStr = jedis.get(lockKey);</span><br><span class="line">				<span class="comment">// timeValue不等：可能发生当前线程lock后，业务操作比较耗时，导致超时后被其他线程lock</span></span><br><span class="line">				<span class="keyword">if</span> (valueStr != <span class="keyword">null</span> &amp;&amp; timeValue == Long.parseLong(valueStr))</span><br><span class="line">					jedis.del(lockKey);</span><br><span class="line">			&#125;</span><br><span class="line">			lockKeys.clear();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			logger.warn(<span class="string">"释放redis lock异常"</span>, e);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.timeValue = <span class="number">0</span>;</span><br><span class="line">			Redis.getInstance().close(jedis);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 匿名类包装：无返回值</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> runnable 需要锁住的运行代码</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true 获锁成功；false 获锁失败</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wrap</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (acquire()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				runnable.run();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(e.getMessage(), e);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				release();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 匿名类包装：带返回值</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> callable 需要锁住的运行代码</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> &lt;V&gt; <span class="function">V <span class="title">wrap</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (acquire()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> callable.call();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				logger.error(e.getMessage(), e);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基于ZK实现"><a href="#基于ZK实现" class="headerlink" title="基于ZK实现"></a>基于ZK实现</h1><p>ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：</p>
<p>（1）创建一个目录mylock；<br>（2）线程A想获取锁就在mylock目录下创建临时顺序节点；<br>（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；<br>（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；<br>（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</p>
<p>这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。</p>
<p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。</p>
<p>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。</p>
<p>在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。<br>当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想，以上包括文中的代码可能并不适用于正式的生产环境，只做入门参考！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.guowenbo.top/2019/01/04/分布式锁及实现/">http://www.guowenbo.top/2019/01/04/分布式锁及实现/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a><a class="post-meta__tags" href="/tags/分布式锁/">分布式锁</a></div><div class="social-share" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2018/12/03/mysql知识点整理/"><span>mysql知识点整理</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '8ee07b919a1bb5d250b7',
  clientSecret: '1d531cc27460532d4dd30ce696004408cc8052d2',
  repo: '87828943.github.io',
  owner: '87828943',
  admin: '87828943',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Guo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>