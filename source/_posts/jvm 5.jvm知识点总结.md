---
title: jvm 5.jvm知识点总结
date: 2018-07-03 15:00:38
tags: [jvm]
categories: jvm
---

# 总体梳理

**jvm体系总体分四大块：**

* 类的加载机制
* jvm内存结构
* GC算法 垃圾回收
* GC分析 命令调优

<!-- more -->

## 类的加载机制

关注点

* 什么是类的加载
* 类的生命周期
* 类加载器
* 双亲委派模型

### 什么是类的加载

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

### 类的生命周期

类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图；

![](/images/2018-06-27/jvm_1_2.png)

* 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象
* 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用
* 初始化，为类的静态变量赋予正确的初始值
* 使用，new出对象程序中使用
* 卸载，执行垃圾回收

***1、JVM初始化步骤 ？ 2、类初始化时机 ？3、哪几种情况下，Java虚拟机将结束生命周期？
答案：[jvm 1.类的加载机制](/2018/06/27/jvm%201.类的加载机制/)***

### 类加载器

![](/images/2018-06-27/jvm_1_3.png)

* 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库
* 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。
* 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器

### 类加载机制

* 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
* 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
* 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

## jvm内存结构

关注点

* jvm内存结构都是什么
* 对象的创建与内存分配

### jvm内存结构都是什么

![](/images/2018-06-29/jvm_2_3.png)

> 方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。

* Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
	1. 年轻代（Eden，form survivor，to survivio 默认8:1:1）
	2. 老年代
* 方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
* 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。
* JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
* 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

### 对象的创建与内存分配

#### 创建对象

当 JVM 收到一个 new 指令时，会检查指令中的参数在常量池是否有这个符号的引用，还会检查该类是否已经被加载过了，如果没有的话则要进行一次类加载。

接着就是分配内存了，通常有两种方式：
1. **指针碰撞**：使用指针碰撞的前提是堆内存是**完全工整**的，用过的内存和没用的内存各在一边每次分配的时候只需要将指针向空闲内存一方移动一段和内存大小相等区域即可。
2. **空闲列表**：当堆中已经使用的内存和未使用的内存**互相交错**时，指针碰撞的方式就行不通了，这时就需要采用空闲列表的方式。虚拟机会维护一个空闲的列表，用于记录哪些内存是可以进行分配的，分配时直接从可用内存中直接分配即可。

堆中的内存是否工整是有**垃圾收集器**来决定的，如果带有压缩功能的垃圾收集器就是采用指针碰撞的方式来进行内存分配的。

#### 内存分配

**Eden 区分配**

简单的来说对象都是在堆内存中分配的，往细一点看则是优先在 Eden 区分配。
这里就涉及到堆内存的划分了，为了方便垃圾回收，JVM 将对内存分为新生代和老年代。
而新生代中又会划分为 Eden 区，from Survivor、to Survivor 区。
其中 Eden 和 Survivor 区的比例默认是 8:1:1，当然也支持参数调整 -XX:SurvivorRatio=8。
当在 Eden 区分配内存不足时，则会发生 minorGC ，由于 Java 对象多数是朝生夕灭的特性，所以 minorGC 通常会比较频繁，效率也比较高。
当发生 minorGC 时，JVM 会根据复制算法将存活的对象拷贝到另一个未使用的 Survivor 区，如果 Survivor 区内存不足时，则会使用分配担保策略将对象移动到老年代中。
谈到 minorGC 时，就不得不提到 fullGC(majorGC) ，这是指发生在老年代的 GC ，不论是效率还是速度都比 minorGC 慢的多，回收时还会发生 stop the world 使程序发生停顿，所以应当尽量避免发生 fullGC 。

**老年代分配**

也有一些情况会导致对象直接在老年代分配，比如当分配一个大对象时(大的数组，很长的字符串)，由于 Eden 区没有足够大的连续空间来分配时，会导致提前触发一次 GC，所以尽量别频繁的创建大对象。
因此 JVM 会根据一个阈值来判断大于该阈值对象直接分配到老年代，这样可以避免在新生代频繁的发生 GC。
对于一些在新生代的老对象 JVM 也会根据某种机制移动到老年代中。
JVM 是根据记录对象年龄的方式来判断该对象是否应该移动到老年代，根据新生代的复制算法，当一个对象被移动到 Survivor 区之后 JVM 就给该对象的年龄记为1，每当熬过一次 minorGC 后对象的年龄就 +1 ，直到达到阈值(默认为15)就移动到老年代中。

> 可以使用 -XX:MaxTenuringThreshold=15 来配置这个阈值。

精简一下：
* 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
* 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
* 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
* 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
* 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。 

***详情：[jvm 2.内存结构](/2018/06/29/jvm%202.内存结构/)***

## GC算法 垃圾回收

关注点

* 对象存活判断
* GC算法
* 垃圾回收器

### 对象存活判断

两种：
1. **引用计数**：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
2. **可达性分析**：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。
	* GC ROOTS
		1. 虚拟机栈引用对象
		2. 本地方法栈引用对象
		3. 方法区常量引用对象
		4. 方法区静态属性引用对象

### GC算法

GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。

* 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
* 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
* 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
* 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
	1. 新生代中存活对象较少,"朝生夕死"，所以采用复制算法，简单高效
	2. 老年代中对象较多，并且没有可以担保的内存区域，所以一般采用标记清除或者是标记整理算法。

### 垃圾回收器

* Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
* ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
* Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
* Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法
* CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
* G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征

***详情：[jvm 3.GC算法-垃圾收集器](/2018/07/02/jvm%203.GC算法-垃圾收集器/)***

## GC分析 命令调优

关注点：

* GC日志分析
* 调优命令
* 调优工具

### GC日志分析

摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：
```bash
	2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K->10738K(274944K)] 371093K->147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs] 
	2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K->0K(274944K)] [ParOldGen: 136447K->140379K(302592K)] 147186K->140379K(577536K) [PSPermGen: 85411K->85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]
```
通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数

young gc 日志:
![](/images/2018-07-03/jvm_5_1.jpg)

Full GC日志:
![](/images/2018-07-03/jvm_5_2.jpg)

### 调优命令

Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo

* **jps**
	jps命令用于查询正在运行的JVM进程，常用的参数为：
    -q:只输出LVMID，省略主类的名称
    -m:输出虚拟机进程启动时传给主类main()函数的参数
    -l:输出主类的全类名，如果进程执行的是Jar包，输出Jar路径
    -v:输出虚拟机进程启动时JVM参数
	命令格式:jps [option] [hostid] 
* **jstat**
	jstat可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据（如果要显示远程JVM信息，需要远程主机开启RMI支持）。如果在服务启动时没有指定启动参数-verbose:gc，则可以用jstat实时查看gc情况。
	jstat有如下选项：
   -class:监视类装载、卸载数量、总空间及类装载所耗费的时间
   -gc:监听Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量，以用空间、GC时间合计等信息
   -gccapacity:监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到的最大和最小空间
   -gcutil:监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比
   -gccause:与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因
   -gcnew:监视新生代GC状况
   -gcnewcapacity:监视内同与-gcnew基本相同，输出主要关注使用到的最大和最小空间
   -gcold:监视老年代GC情况
   -gcoldcapacity:监视内同与-gcold基本相同，输出主要关注使用到的最大和最小空间
   -gcpermcapacity:输出永久代使用到最大和最小空间
   -compiler:输出JIT编译器编译过的方法、耗时等信息
   -printcompilation:输出已经被JIT编译的方法
	命令格式:jstat [option vmid [interval[s|ms] [count]]]
* **jmap**
	用于显示当前Java堆和永久代的详细信息（如当前使用的收集器，当前的空间使用率等）
   -dump:生成java堆转储快照
   -heap:显示java堆详细信息(只在Linux/Solaris下有效)
   -F:当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照(只在Linux/Solaris下有效)
   -finalizerinfo:显示在F-Queue中等待Finalizer线程执行finalize方法的对象(只在Linux/Solaris下有效)
   -histo:显示堆中对象统计信息
   -permstat:以ClassLoader为统计口径显示永久代内存状态(只在Linux/Solaris下有效)
	命令格式:jmap [option] vmid
	其中前面3个参数最重要，如：
	查看对详细信息：sudo jmap -heap 309
	生成dump文件： sudo jmap -dump:file=./test.prof 309
	部分用户没有权限时，采用admin用户：sudo -u admin -H  jmap -dump:format=b,file=文件名.hprof pid
	查看当前堆中对象统计信息：sudo  jmap -histo 309：该命令显示3列，分别为对象数量，对象大小，对象名称，通过该命令可以查看是否内存中有大对象；
	有的用户可能没有jmap权限：sudo -u admin -H jmap -histo 309 | less
* **jhat**
	用于分析使用jmap生成的dump文件，是JDK自带的工具，使用方法为： jhat -J -Xmx512m [file]
	不过jhat没有mat好用，推荐使用mat（Eclipse插件： http://www.eclipse.org/mat ），mat速度更快，而且是图形界面
* **jstack**
	用于生成当前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法,目的是定位线程出现长时间停顿的原因。
   -F:当正常输出的请求不被响应时，强制输出线程堆栈
   -l:除堆栈外，显示关于锁的附加信息
   -m:如果调用到本地方法的话，可以显示C/C++的堆栈
	命令格式:jstack [option] vmid
* **jinfo**
	用于查询当前运行这的JVM属性和参数的值。
	jinfo可以使用如下选项：
   -flag:显示未被显示指定的参数的系统默认值
   -flag [+|-]name或-flag name=value: 修改部分参数
   -sysprops:打印虚拟机进程的System.getProperties()
	命令格式:jinfo [option] pid 

### 调优工具

常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。

* jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控
* jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。
* MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗
* GChisto，一款专业分析gc日志的工具
有兴趣的可以看看下面的文章，在此不再赘述：
http://blog.csdn.net/java2000_wl/article/details/8049707

***详情：[jvm 4.如何优化Java-GC「译」](/2018/07/03/jvm%204.如何优化Java-GC「译」/)***