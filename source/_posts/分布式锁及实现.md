---
title: 分布式锁及实现
date: 2019-01-04 15:01:57
tags: [分布式锁,redis]
---

> 目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。

在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。

* 基于数据库实现分布式锁；
* 基于缓存（Redis等）实现分布式锁；
* 基于Zookeeper实现分布式锁；

在分析这几种实现方案之前我们先来想一下，我们需要的分布式锁应该是怎么样的？（这里以方法锁为例，资源锁同理）

> 可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。
这把锁要是一把可重入锁（避免死锁）
这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）
有高可用的获取锁和释放锁功能
获取锁和释放锁的性能要好

<!-- more -->

# 基于数据库实现

> 基于数据库表实现（唯一性索引）

最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。

当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。

（1）创建这样一张数据库表：

```java
CREATE TABLE `method_lock` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `method_name` varchar(64) NOT NULL COMMENT '锁定的方法名',
  `desc` varchar(255) NOT NULL COMMENT '备注信息',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
```

（2）当我们想要锁住某个方法时，执行以下SQL：

```java
INSERT INTO method_lock (method_name, desc) VALUES ('methodName', '测试的methodName');
```

因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

（3）成功插入则获取锁，执行完成后删除对应的行数据释放锁：

```java
delete from method_lock where method_name ='methodName';
```

上面这种简单的实现有以下几个问题：

1. 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。
2. 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
3. 这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。
4. 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。

当然，我们也可以有其他方式解决上面的问题。

* 数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。
* 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。
* 非阻塞的？搞一个while循环，直到insert成功再返回成功。
* 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。

# 基于redis实现

（1）Redis有很高的性能； 
（2）Redis命令对此支持较好，实现起来比较方便

命令介绍：

（1）SETNX
```java
SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。
```
（2）expire
```java
expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。
```
（3）delete
```java
delete key：删除key
```

代码实现

```java
/**
 * Redis Lock：redis锁（注意：必须在事务外使用，否则解锁-事务提交之间，可能被其他线程lock，导致脏读）
 */
public class RedisLock {

	private static Logger logger = LoggerFactory.getLogger(RedisLock.class);

	private String[] keys;
	private int expireSeconds; // 过期时间
	private int retrySeconds; // 重试时间
	private long timeValue = 0; // lock设置的时间戳：0 失败；>0 时间戳

	private String lockPrefix;// 前缀
	private List<String> lockKeys; // 已加锁的key列表

	public RedisLock(String[] keys, int expireSeconds, int retrySeconds) {
		this.keys= keys;
		this.expireSeconds = expireSeconds;
		this.retrySeconds = retrySeconds;
	}

	public int getExpireSeconds() {
		return expireSeconds;
	}

	public void setExpireSeconds(int expireSeconds) {
		this.expireSeconds = expireSeconds;
	}

	public int getRetrySeconds() {
		return retrySeconds;
	}

	public void setRetrySeconds(int retrySeconds) {
		this.retrySeconds = retrySeconds;
	}

	public String[] getKeys() {
		return keys;
	}

	public String getKeyString() {
		return StringUtils.join(this.keys, ",");
	}

	public long getTimeValue() {
		return timeValue;
	}

	public List<String> getLockKeys() {
		return lockKeys;
	}

	/**
	 * 排序自旋锁：setnx && expire
	 */
	public boolean acquire() {
		//双重检查单例Redis
		Jedis jedis = Redis.getInstance().getJedis();
		try {
			Arrays.sort(keys);
			lockKeys.clear();
			long now = System.currentTimeMillis();
			// 避免死锁：value = 当前时间 + 过期时间 + 1毫秒
			this.timeValue = now + expireSeconds * 1000 + 1;
			while (true) {
				for (String key : keys) {
					String lockKey = lockPrefix + key;
					if (lockKeys.contains(lockKey))
						continue;

					Long ret = jedis.setnx(lockKey, String.valueOf(timeValue));
					if (ret == 1) {
						// 使用expire，如果代码运行至此，redis连接崩溃，该key没有设置超时时间 => 死锁
						jedis.expire(lockKey, expireSeconds);
						lockKeys.add(lockKey);
					}
					// 解决死锁：判断key对应的value是否超时
					else {
						String currentValueStr = jedis.get(lockKey);
						if (currentValueStr != null && System.currentTimeMillis() > Long.valueOf(currentValueStr)) {
							// 并发竞争：getset取出旧值再判断一次，避免被其他线程set
							String oldValueStr = jedis.getSet(lockKey, String.valueOf(timeValue));
							if (oldValueStr == null || oldValueStr.equals(currentValueStr)) {
								lockKeys.add(lockKey);
								continue;
							}
						}
						break;
					}
				}
				// 全部锁住
				if (lockKeys.size() == keys.length) {
					return true;
				}
				// 超时未成功：释放加的锁
				else if (System.currentTimeMillis() - now > retrySeconds * 1000) {
					if (lockKeys.size() > 0) {
						jedis.del(lockKeys.toArray(new String[lockKeys.size()]));
						lockKeys.clear();
					}
					return false;
				}

				Thread.sleep(200);
			}
		} catch (Exception e) {
			logger.warn("获取redis lock异常", e);
			if (lockKeys.size() > 0) {
				jedis.del(lockKeys.toArray(new String[lockKeys.size()]));
				lockKeys.clear();
			}
			return false;
		} finally {
			Redis.getInstance().close(jedis);
		}
	}

	/**
	 * 解锁：删除 key（从redis线程池未获取到jedis => 解锁失败）
	 */
	public void release() {
		//双重检查单例Redis
		Jedis jedis = Redis.getInstance().getJedis();
		try {
			for (String lockKey : lockKeys) {
				String valueStr = jedis.get(lockKey);
				// timeValue不等：可能发生当前线程lock后，业务操作比较耗时，导致超时后被其他线程lock
				if (valueStr != null && timeValue == Long.parseLong(valueStr))
					jedis.del(lockKey);
			}
			lockKeys.clear();
		} catch (Exception e) {
			logger.warn("释放redis lock异常", e);
		} finally {
			this.timeValue = 0;
			Redis.getInstance().close(jedis);
		}
	}

	/**
	 * 匿名类包装：无返回值
	 * 
	 * @param runnable 需要锁住的运行代码
	 * @return true 获锁成功；false 获锁失败
	 */
	public boolean wrap(Runnable runnable) {
		if (acquire()) {
			try {
				runnable.run();
			} catch (Exception e) {
				logger.error(e.getMessage(), e);
			} finally {
				release();
			}
			return true;
		}
		else
			return false;
	}

	/**
	 * 匿名类包装：带返回值
	 * 
	 * @param callable 需要锁住的运行代码
	 */
	public <V> V wrap(Callable<V> callable) {
		if (acquire()) {
			try {
				return callable.call();
			} catch (Exception e) {
				logger.error(e.getMessage(), e);
			} finally {
				release();
			}
		}
		else
			return null;
	}

}
```

# 基于ZK实现

ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：

（1）创建一个目录mylock； 
（2）线程A想获取锁就在mylock目录下创建临时顺序节点； 
（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； 
（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； 
（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。

优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。

# 总结

上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。

在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。 
当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想，以上包括文中的代码可能并不适用于正式的生产环境，只做入门参考！